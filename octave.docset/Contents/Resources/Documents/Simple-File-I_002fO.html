<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.3, http://www.gnu.org/software/texinfo/ -->
<head>
<title>GNU Octave: Simple File I/O</title>

<meta name="description" content="GNU Octave: Simple File I/O">
<meta name="keywords" content="GNU Octave: Simple File I/O">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="Concept-Index.html#Concept-Index" rel="index" title="Concept Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Basic-Input-and-Output.html#Basic-Input-and-Output" rel="up" title="Basic Input and Output">
<link href="Saving-Data-on-Unexpected-Exits.html#Saving-Data-on-Unexpected-Exits" rel="next" title="Saving Data on Unexpected Exits">
<link href="Terminal-Input.html#Terminal-Input" rel="prev" title="Terminal Input">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="octave.css">


</head>

<body lang="en">
<a name="Simple-File-I_002fO"></a>
<div class="header">
<p>
Previous: <a href="Terminal-Input.html#Terminal-Input" accesskey="p" rel="prev">Terminal Input</a>, Up: <a href="Basic-Input-and-Output.html#Basic-Input-and-Output" accesskey="u" rel="up">Basic Input and Output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<a name="Simple-File-I_002fO-1"></a>
<h4 class="subsection">14.1.3 Simple File I/O</h4>

<a name="index-saving-data"></a>
<a name="index-loading-data"></a>
<p>The <code>save</code> and <code>load</code> commands allow data to be written to and
read from disk files in various formats.  The default format of files
written by the <code>save</code> command can be controlled using the functions
<code>save_default_options</code> and <code>save_precision</code>.
</p>
<p>As an example the following code creates a 3-by-3 matrix and saves it
to the file &lsquo;<samp>myfile.mat</samp>&rsquo;.
</p>
<div class="example">
<pre class="example">A = [ 1:3; 4:6; 7:9 ];
save myfile.mat A
</pre></div>

<p>Once one or more variables have been saved to a file, they can be
read into memory using the <code>load</code> command.
</p>
<div class="example">
<pre class="example">load myfile.mat
A
     -| A =
     -|
     -|    1   2   3
     -|    4   5   6
     -|    7   8   9
</pre></div>

<a name="XREFsave"></a><dl>
<dt><a name="index-save"></a>: <em></em> <strong>save</strong> <em>file</em></dt>
<dt><a name="index-save-1"></a>: <em></em> <strong>save</strong> <em>options file</em></dt>
<dt><a name="index-save-2"></a>: <em></em> <strong>save</strong> <em>options file <var>v1</var> <var>v2</var> &hellip;</em></dt>
<dt><a name="index-save-3"></a>: <em></em> <strong>save</strong> <em>options file -struct <var>STRUCT</var> <var>f1</var> <var>f2</var> &hellip;</em></dt>
<dt><a name="index-save-4"></a>: <em></em> <strong>save</strong> <em>- <var>v1</var> <var>v2</var> &hellip;</em></dt>
<dt><a name="index-save-5"></a>: <em><var>str</var> =</em> <strong>save</strong> <em>(&quot;-&quot;, <code>&quot;<var>v1</var>&quot;</code>, <code>&quot;<var>v2</var>&quot;</code>, &hellip;)</em></dt>
<dd><p>Save the named variables <var>v1</var>, <var>v2</var>, &hellip;, in the file
<var>file</var>.
</p>
<p>The special filename &lsquo;<samp>-</samp>&rsquo; may be used to return the
content of the variables as a string.  If no variable names are listed,
Octave saves all the variables in the current scope.  Otherwise, full
variable names or pattern syntax can be used to specify the variables to
save.  If the <samp>-struct</samp> modifier is used, fields <var>f1</var> <var>f2</var>
&hellip; of the scalar structure <var>STRUCT</var> are saved as if they were
variables with corresponding names.  Valid options for the <code>save</code>
command are listed in the following table.  Options that modify the output
format override the format specified by <code>save_default_options</code>.
</p>
<p>If save is invoked using the functional form
</p>
<div class="example">
<pre class="example">save (&quot;-option1&quot;, &hellip;, &quot;file&quot;, &quot;v1&quot;, &hellip;)
</pre></div>

<p>then the <var>options</var>, <var>file</var>, and variable name arguments
(<var>v1</var>, &hellip;) must be specified as character strings.
</p>
<p>If called with a filename of <code>&quot;-&quot;</code>, write the output to stdout
if nargout is 0, otherwise return the output in a character string.
</p>
<dl compact="compact">
<dt><code>-append</code></dt>
<dd><p>Append to the destination instead of overwriting.
</p>
</dd>
<dt><code>-ascii</code></dt>
<dd><p>Save a single matrix in a text file without header or any other information.
</p>
</dd>
<dt><code>-binary</code></dt>
<dd><p>Save the data in Octave&rsquo;s binary data format.
</p>
</dd>
<dt><code>-float-binary</code></dt>
<dd><p>Save the data in Octave&rsquo;s binary data format but only using single
precision.  Only use this format if you know that all the
values to be saved can be represented in single precision.
</p>
</dd>
<dt><code>-hdf5</code></dt>
<dd><p>Save the data in <small>HDF5</small> format.
(HDF5 is a free, portable binary format developed by the National
Center for Supercomputing Applications at the University of Illinois.)
This format is only available if Octave was built with a link to the
<small>HDF5</small> libraries.
</p>
</dd>
<dt><code>-float-hdf5</code></dt>
<dd><p>Save the data in <small>HDF5</small> format but only using single precision.
Only use this format if you know that all the
values to be saved can be represented in single precision.
</p>
</dd>
<dt><code>-V7</code></dt>
<dt><code>-v7</code></dt>
<dt><code>-7</code></dt>
<dt><code>-mat7-binary</code></dt>
<dd><p>Save the data in <small>MATLAB</small>&rsquo;s v7 binary data format.
</p>
</dd>
<dt><code>-V6</code></dt>
<dt><code>-v6</code></dt>
<dt><code>-6</code></dt>
<dt><code>-mat</code></dt>
<dt><code>-mat-binary</code></dt>
<dd><p>Save the data in <small>MATLAB</small>&rsquo;s v6 binary data format.
</p>
</dd>
<dt><code>-V4</code></dt>
<dt><code>-v4</code></dt>
<dt><code>-4</code></dt>
<dt><code>-mat4-binary</code></dt>
<dd><p>Save the data in the binary format written by <small>MATLAB</small> version 4.
</p>
</dd>
<dt><code>-text</code></dt>
<dd><p>Save the data in Octave&rsquo;s text data format.  (default).
</p>
</dd>
<dt><code>-zip</code></dt>
<dt><code>-z</code></dt>
<dd><p>Use the gzip algorithm to compress the file.  This works equally on files
that are compressed with gzip outside of octave, and gzip can equally be
used to convert the files for backward compatibility.
This option is only available if Octave was built with a link to the zlib
libraries.
</p></dd>
</dl>

<p>The list of variables to save may use wildcard patterns containing
the following special characters:
</p>
<dl compact="compact">
<dt><code>?</code></dt>
<dd><p>Match any single character.
</p>
</dd>
<dt><code>*</code></dt>
<dd><p>Match zero or more characters.
</p>
</dd>
<dt><code>[ <var>list</var> ]</code></dt>
<dd><p>Match the list of characters specified by <var>list</var>.  If the first
character is <code>!</code> or <code>^</code>, match all characters except those
specified by <var>list</var>.  For example, the pattern <code>[a-zA-Z]</code> will
match all lower and uppercase alphabetic characters.
</p>
<p>Wildcards may also be used in the field name specifications when using
the <samp>-struct</samp> modifier (but not in the struct name itself).
</p>
</dd>
</dl>

<p>Except when using the <small>MATLAB</small> binary data file format or the
&lsquo;<samp>-ascii</samp>&rsquo; format, saving global
variables also saves the global status of the variable.  If the variable
is restored at a later time using &lsquo;<samp>load</samp>&rsquo;, it will be restored as a
global variable.
</p>
<p>The command
</p>
<div class="example">
<pre class="example">save -binary data a b*
</pre></div>

<p>saves the variable &lsquo;<samp>a</samp>&rsquo; and all variables beginning with &lsquo;<samp>b</samp>&rsquo; to
the file <samp>data</samp> in Octave&rsquo;s binary format.
</p>
<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFload">load</a>, <a href="Simple-File-I_002fO.html#XREFsave_005fdefault_005foptions">save_default_options</a>, <a href="Simple-File-I_002fO.html#XREFsave_005fheader_005fformat_005fstring">save_header_format_string</a>, <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>, <a href="Simple-File-I_002fO.html#XREFcsvread">csvread</a>, <a href="Binary-I_002fO.html#XREFfread">fread</a>.
</p></dd></dl>


<p>There are three functions that modify the behavior of <code>save</code>.
</p>
<a name="XREFsave_005fdefault_005foptions"></a><dl>
<dt><a name="index-save_005fdefault_005foptions"></a>: <em><var>val</var> =</em> <strong>save_default_options</strong> <em>()</em></dt>
<dt><a name="index-save_005fdefault_005foptions-1"></a>: <em><var>old_val</var> =</em> <strong>save_default_options</strong> <em>(<var>new_val</var>)</em></dt>
<dt><a name="index-save_005fdefault_005foptions-2"></a>: <em></em> <strong>save_default_options</strong> <em>(<var>new_val</var>, &quot;local&quot;)</em></dt>
<dd><p>Query or set the internal variable that specifies the default options
for the <code>save</code> command, and defines the default format.
</p>
<p>Typical values include <code>&quot;-ascii&quot;</code>, <code>&quot;-text -zip&quot;</code>.
The default value is <samp>-text</samp>.
</p>
<p>When called from inside a function with the <code>&quot;local&quot;</code> option, the
variable is changed locally for the function and any subroutines it calls.
The original variable value is restored when exiting the function.
</p>
<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFsave">save</a>.
</p></dd></dl>


<a name="XREFsave_005fprecision"></a><dl>
<dt><a name="index-save_005fprecision"></a>: <em><var>val</var> =</em> <strong>save_precision</strong> <em>()</em></dt>
<dt><a name="index-save_005fprecision-1"></a>: <em><var>old_val</var> =</em> <strong>save_precision</strong> <em>(<var>new_val</var>)</em></dt>
<dt><a name="index-save_005fprecision-2"></a>: <em></em> <strong>save_precision</strong> <em>(<var>new_val</var>, &quot;local&quot;)</em></dt>
<dd><p>Query or set the internal variable that specifies the number of digits to
keep when saving data in text format.
</p>
<p>When called from inside a function with the <code>&quot;local&quot;</code> option, the
variable is changed locally for the function and any subroutines it calls.
The original variable value is restored when exiting the function.
</p></dd></dl>


<a name="XREFsave_005fheader_005fformat_005fstring"></a><dl>
<dt><a name="index-save_005fheader_005fformat_005fstring"></a>: <em><var>val</var> =</em> <strong>save_header_format_string</strong> <em>()</em></dt>
<dt><a name="index-save_005fheader_005fformat_005fstring-1"></a>: <em><var>old_val</var> =</em> <strong>save_header_format_string</strong> <em>(<var>new_val</var>)</em></dt>
<dt><a name="index-save_005fheader_005fformat_005fstring-2"></a>: <em></em> <strong>save_header_format_string</strong> <em>(<var>new_val</var>, &quot;local&quot;)</em></dt>
<dd><p>Query or set the internal variable that specifies the format
string used for the comment line written at the beginning of
text-format data files saved by Octave.
</p>
<p>The format string is passed to <code>strftime</code> and should begin with the
character &lsquo;<samp>#</samp>&rsquo; and contain no newline characters.  If the value of
<code>save_header_format_string</code> is the empty string, the header comment is
omitted from text-format data files.  The default value is
</p>
<div class="smallexample">
<pre class="smallexample">&quot;# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z &lt;USER@HOST&gt;&quot;
</pre></div>

<p>When called from inside a function with the <code>&quot;local&quot;</code> option, the
variable is changed locally for the function and any subroutines it calls.
The original variable value is restored when exiting the function.
</p>
<p><strong>See also:</strong> <a href="Timing-Utilities.html#XREFstrftime">strftime</a>, <a href="Simple-File-I_002fO.html#XREFsave">save</a>.
</p></dd></dl>


<a name="XREFload"></a><dl>
<dt><a name="index-load"></a>: <em></em> <strong>load</strong> <em>file</em></dt>
<dt><a name="index-load-1"></a>: <em></em> <strong>load</strong> <em>options file</em></dt>
<dt><a name="index-load-2"></a>: <em></em> <strong>load</strong> <em>options file v1 v2 &hellip;</em></dt>
<dt><a name="index-load-3"></a>: <em>S =</em> <strong>load</strong> <em>(&quot;options&quot;, &quot;file&quot;, &quot;v1&quot;, &quot;v2&quot;, &hellip;)</em></dt>
<dt><a name="index-load-4"></a>: <em></em> <strong>load</strong> <em>file options</em></dt>
<dt><a name="index-load-5"></a>: <em></em> <strong>load</strong> <em>file options v1 v2 &hellip;</em></dt>
<dt><a name="index-load-6"></a>: <em>S =</em> <strong>load</strong> <em>(&quot;file&quot;, &quot;options&quot;, &quot;v1&quot;, &quot;v2&quot;, &hellip;)</em></dt>
<dd><p>Load the named variables <var>v1</var>, <var>v2</var>, &hellip;, from the file
<var>file</var>.
</p>
<p>If no variables are specified then all variables found in the
file will be loaded.  As with <code>save</code>, the list of variables to extract
can be full names or use a pattern syntax.  The format of the file is
automatically detected but may be overridden by supplying the appropriate
option.
</p>
<p>If load is invoked using the functional form
</p>
<div class="example">
<pre class="example">load (&quot;-option1&quot;, &hellip;, &quot;file&quot;, &quot;v1&quot;, &hellip;)
</pre></div>

<p>then the <var>options</var>, <var>file</var>, and variable name arguments
(<var>v1</var>, &hellip;) must be specified as character strings.
</p>
<p>If a variable that is not marked as global is loaded from a file when a
global symbol with the same name already exists, it is loaded in the
global symbol table.  Also, if a variable is marked as global in a file
and a local symbol exists, the local symbol is moved to the global
symbol table and given the value from the file.
</p>
<p>If invoked with a single output argument, Octave returns data instead
of inserting variables in the symbol table.  If the data file contains
only numbers (TAB- or space-delimited columns), a matrix of values is
returned.  Otherwise, <code>load</code> returns a structure with members
 corresponding to the names of the variables in the file.
</p>
<p>The <code>load</code> command can read data stored in Octave&rsquo;s text and
binary formats, and <small>MATLAB</small>&rsquo;s binary format.  If compiled with zlib
support, it can also load gzip-compressed files.  It will automatically
detect the type of file and do conversion from different floating point
formats (currently only IEEE big and little endian, though other formats
may be added in the future).
</p>
<p>Valid options for <code>load</code> are listed in the following table.
</p>
<dl compact="compact">
<dt><code>-force</code></dt>
<dd><p>This option is accepted for backward compatibility but is ignored.
Octave now overwrites variables currently in memory with
those of the same name found in the file.
</p>
</dd>
<dt><code>-ascii</code></dt>
<dd><p>Force Octave to assume the file contains columns of numbers in text format
without any header or other information.  Data in the file will be loaded
as a single numeric matrix with the name of the variable derived from the
name of the file.
</p>
</dd>
<dt><code>-binary</code></dt>
<dd><p>Force Octave to assume the file is in Octave&rsquo;s binary format.
</p>
</dd>
<dt><code>-hdf5</code></dt>
<dd><p>Force Octave to assume the file is in <small>HDF5</small> format.
(<small>HDF5</small> is a free, portable binary format developed by the National
Center for Supercomputing Applications at the University of Illinois.)
Note that Octave can read <small>HDF5</small> files not created by itself, but may
skip some datasets in formats that it cannot support.  This format is
only available if Octave was built with a link to the <small>HDF5</small> libraries.
</p>
</dd>
<dt><code>-import</code></dt>
<dd><p>This option is accepted for backward compatibility but is ignored.
Octave can now support multi-dimensional HDF data and automatically
modifies variable names if they are invalid Octave identifiers.
</p>
</dd>
<dt><code>-mat</code></dt>
<dt><code>-mat-binary</code></dt>
<dt><code>-6</code></dt>
<dt><code>-v6</code></dt>
<dt><code>-7</code></dt>
<dt><code>-v7</code></dt>
<dd><p>Force Octave to assume the file is in <small>MATLAB</small>&rsquo;s version 6 or 7 binary
format.
</p>
</dd>
<dt><code>-mat4-binary</code></dt>
<dt><code>-4</code></dt>
<dt><code>-v4</code></dt>
<dt><code>-V4</code></dt>
<dd><p>Force Octave to assume the file is in the binary format written by
<small>MATLAB</small> version 4.
</p>
</dd>
<dt><code>-text</code></dt>
<dd><p>Force Octave to assume the file is in Octave&rsquo;s text format.
</p></dd>
</dl>

<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFsave">save</a>, <a href="Simple-File-I_002fO.html#XREFdlmwrite">dlmwrite</a>, <a href="Simple-File-I_002fO.html#XREFcsvwrite">csvwrite</a>, <a href="Binary-I_002fO.html#XREFfwrite">fwrite</a>.
</p></dd></dl>


<a name="XREFfileread"></a><dl>
<dt><a name="index-fileread"></a>: <em><var>str</var> =</em> <strong>fileread</strong> <em>(<var>filename</var>)</em></dt>
<dd><p>Read the contents of <var>filename</var> and return it as a string.
</p>
<p><strong>See also:</strong> <a href="Binary-I_002fO.html#XREFfread">fread</a>, <a href="Simple-File-I_002fO.html#XREFtextread">textread</a>, <a href="Formatted-Input.html#XREFsscanf">sscanf</a>.
</p></dd></dl>


<a name="XREFnative_005ffloat_005fformat"></a><dl>
<dt><a name="index-native_005ffloat_005fformat"></a>: <em></em> <strong>native_float_format</strong> <em>()</em></dt>
<dd><p>Return the native floating point format as a string.
</p></dd></dl>


<p>It is possible to write data to a file in a similar way to the
<code>disp</code> function for writing data to the screen.  The <code>fdisp</code>
works just like <code>disp</code> except its first argument is a file pointer
as created by <code>fopen</code>.  As an example, the following code writes
to data &lsquo;<samp>myfile.txt</samp>&rsquo;.
</p>
<div class="example">
<pre class="example">fid = fopen (&quot;myfile.txt&quot;, &quot;w&quot;);
fdisp (fid, &quot;3/8 is &quot;);
fdisp (fid, 3/8);
fclose (fid);
</pre></div>

<p>See <a href="Opening-and-Closing-Files.html#Opening-and-Closing-Files">Opening and Closing Files</a>, for details on how to use <code>fopen</code>
and <code>fclose</code>.
</p>
<a name="XREFfdisp"></a><dl>
<dt><a name="index-fdisp"></a>: <em></em> <strong>fdisp</strong> <em>(<var>fid</var>, <var>x</var>)</em></dt>
<dd><p>Display the value of <var>x</var> on the stream <var>fid</var>.
</p>
<p>For example:
</p>
<div class="example">
<pre class="example">fdisp (stdout, &quot;The value of pi is:&quot;), fdisp (stdout, pi)

     -| the value of pi is:
     -| 3.1416
</pre></div>

<p>Note that the output from <code>fdisp</code> always ends with a newline.
</p>
<p><strong>See also:</strong> <a href="Terminal-Output.html#XREFdisp">disp</a>.
</p></dd></dl>


<p>Octave can also read and write matrices text files such as comma
separated lists.
</p>
<a name="XREFdlmwrite"></a><dl>
<dt><a name="index-dlmwrite"></a>: <em></em> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>)</em></dt>
<dt><a name="index-dlmwrite-1"></a>: <em></em> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>, <var>delim</var>, <var>r</var>, <var>c</var>)</em></dt>
<dt><a name="index-dlmwrite-2"></a>: <em></em> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>, <var>key</var>, <var>val</var> &hellip;)</em></dt>
<dt><a name="index-dlmwrite-3"></a>: <em></em> <strong>dlmwrite</strong> <em>(<var>file</var>, <var>M</var>, &quot;-append&quot;, &hellip;)</em></dt>
<dt><a name="index-dlmwrite-4"></a>: <em></em> <strong>dlmwrite</strong> <em>(<var>fid</var>, &hellip;)</em></dt>
<dd><p>Write the numeric matrix <var>M</var> to the text file <var>file</var> using a
delimiter.
</p>
<p><var>file</var> should be a filename or a writable file ID given by <code>fopen</code>.
</p>
<p>The parameter <var>delim</var> specifies the delimiter to use to separate values
on a row.  If no delimiter is specified the comma character &lsquo;<samp>,</samp>&rsquo; is
used.
</p>
<p>The value of <var>r</var> specifies the number of delimiter-only lines to add to
the start of the file.
</p>
<p>The value of <var>c</var> specifies the number of delimiters to prepend to each
line of data.
</p>
<p>If the argument <code>&quot;-append&quot;</code> is given, append to the end of <var>file</var>.
</p>
<p>In addition, the following keyword value pairs may appear at the end of
the argument list:
</p>
<dl compact="compact">
<dt><code>&quot;append&quot;</code></dt>
<dd><p>Either <code>&quot;on&quot;</code> or <code>&quot;off&quot;</code>.  See <code>&quot;-append&quot;</code> above.
</p>
</dd>
<dt><code>&quot;delimiter&quot;</code></dt>
<dd><p>See <var>delim</var> above.
</p>
</dd>
<dt><code>&quot;newline&quot;</code></dt>
<dd><p>The character(s) to separate each row.  Three special cases exist for this
option.  <code>&quot;unix&quot;</code> is changed into <code>&quot;\n&quot;</code>,
<code>&quot;pc&quot;</code> is changed into <code>&quot;\r\n&quot;</code>,
and <code>&quot;mac&quot;</code> is changed into <code>&quot;\r&quot;</code>.  Any other
value is used directly as the newline separator.
</p>
</dd>
<dt><code>&quot;roffset&quot;</code></dt>
<dd><p>See <var>r</var> above.
</p>
</dd>
<dt><code>&quot;coffset&quot;</code></dt>
<dd><p>See <var>c</var> above.
</p>
</dd>
<dt><code>&quot;precision&quot;</code></dt>
<dd><p>The precision to use when writing the file.  It can either be a format
string (as used by fprintf) or a number of significant digits.
</p></dd>
</dl>

<div class="example">
<pre class="example">dlmwrite (&quot;file.csv&quot;, reshape (1:16, 4, 4));
</pre></div>

<div class="example">
<pre class="example">dlmwrite (&quot;file.tex&quot;, a, &quot;delimiter&quot;, &quot;&amp;&quot;, &quot;newline&quot;, &quot;\n&quot;)
</pre></div>


<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>, <a href="Simple-File-I_002fO.html#XREFcsvread">csvread</a>, <a href="Simple-File-I_002fO.html#XREFcsvwrite">csvwrite</a>.
</p></dd></dl>


<a name="XREFdlmread"></a><dl>
<dt><a name="index-dlmread"></a>: <em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>)</em></dt>
<dt><a name="index-dlmread-1"></a>: <em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>, <var>sep</var>)</em></dt>
<dt><a name="index-dlmread-2"></a>: <em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>, <var>sep</var>, <var>r0</var>, <var>c0</var>)</em></dt>
<dt><a name="index-dlmread-3"></a>: <em><var>data</var> =</em> <strong>dlmread</strong> <em>(<var>file</var>, <var>sep</var>, <var>range</var>)</em></dt>
<dt><a name="index-dlmread-4"></a>: <em><var>data</var> =</em> <strong>dlmread</strong> <em>(&hellip;, &quot;emptyvalue&quot;, <var>EMPTYVAL</var>)</em></dt>
<dd><p>Read numeric data from the text file <var>file</var> which uses the delimiter
<var>sep</var> between data values.
</p>
<p>If <var>sep</var> is not defined the separator between fields is determined from
the file itself.
</p>
<p>The optional scalar arguments <var>r0</var> and <var>c0</var> define the starting row
and column of the data to be read.  These values are indexed from zero,
i.e., the first data row corresponds to an index of zero.
</p>
<p>The <var>range</var> parameter specifies exactly which data elements are read.
The first form of the parameter is a 4-element vector containing the upper
left and lower right corners <code>[<var>R0</var>,<var>C0</var>,<var>R1</var>,<var>C1</var>]</code>
where the indices are zero-based.  Alternatively, a spreadsheet style
form such as <code>&quot;A2..Q15&quot;</code> or <code>&quot;T1:AA5&quot;</code> can be used.  The
lowest alphabetical index <code>'A'</code> refers to the first column.  The
lowest row index is 1.
</p>
<p><var>file</var> should be a filename or a file id given by <code>fopen</code>.  In the
latter case, the file is read until end of file is reached.
</p>
<p>The <code>&quot;emptyvalue&quot;</code> option may be used to specify the value used to
fill empty fields.  The default is zero.  Note that any non-numeric values,
such as text, are also replaced by the <code>&quot;emptyvalue&quot;</code>.
</p>
<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFcsvread">csvread</a>, <a href="Simple-File-I_002fO.html#XREFtextscan">textscan</a>, <a href="Simple-File-I_002fO.html#XREFtextread">textread</a>, <a href="Simple-File-I_002fO.html#XREFdlmwrite">dlmwrite</a>.
</p></dd></dl>


<a name="XREFcsvwrite"></a><dl>
<dt><a name="index-csvwrite"></a>: <em></em> <strong>csvwrite</strong> <em>(<var>filename</var>, <var>x</var>)</em></dt>
<dt><a name="index-csvwrite-1"></a>: <em></em> <strong>csvwrite</strong> <em>(<var>filename</var>, <var>x</var>, <var>dlm_opt1</var>, &hellip;)</em></dt>
<dd><p>Write the numeric matrix <var>x</var> to the file <var>filename</var> in
<span class="nolinebreak">comma-separated-value</span><!-- /@w --> (CSV) format.
</p>
<p>This function is equivalent to
</p>
<div class="example">
<pre class="example">dlmwrite (<var>filename</var>, <var>x</var>, &quot;,&quot;, <var>dlm_opt1</var>, &hellip;)
</pre></div>

<p>Any optional arguments are passed directly to <code>dlmwrite</code>
(see <a href="Simple-File-I_002fO.html#XREFdlmwrite">dlmwrite</a>).
</p>
<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFcsvread">csvread</a>, <a href="Simple-File-I_002fO.html#XREFdlmwrite">dlmwrite</a>, <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>.
</p></dd></dl>


<a name="XREFcsvread"></a><dl>
<dt><a name="index-csvread"></a>: <em><var>x</var> =</em> <strong>csvread</strong> <em>(<var>filename</var>)</em></dt>
<dt><a name="index-csvread-1"></a>: <em><var>x</var> =</em> <strong>csvread</strong> <em>(<var>filename</var>, <var>dlm_opt1</var>, &hellip;)</em></dt>
<dd><p>Read the comma-separated-value (CSV) file <var>filename</var> into the matrix
<var>x</var>.
</p>
<p>Note: only CSV files containing numeric data can be read.
</p>
<p>This function is equivalent to
</p>
<div class="example">
<pre class="example"><var>x</var> = dlmread (<var>filename</var>, &quot;,&quot; , <var>dlm_opt1</var>, &hellip;)
</pre></div>

<p>Any optional arguments are passed directly to <code>dlmread</code>
(see <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>).
</p>
<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>, <a href="Simple-File-I_002fO.html#XREFtextread">textread</a>, <a href="Simple-File-I_002fO.html#XREFtextscan">textscan</a>, <a href="Simple-File-I_002fO.html#XREFcsvwrite">csvwrite</a>, <a href="Simple-File-I_002fO.html#XREFdlmwrite">dlmwrite</a>.
</p></dd></dl>


<p>Formatted data from can be read from, or written to, text files as well.
</p>
<a name="XREFtextread"></a><dl>
<dt><a name="index-textread"></a>: <em>[<var>a</var>, &hellip;] =</em> <strong>textread</strong> <em>(<var>filename</var>)</em></dt>
<dt><a name="index-textread-1"></a>: <em>[<var>a</var>, &hellip;] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>)</em></dt>
<dt><a name="index-textread-2"></a>: <em>[<var>a</var>, &hellip;] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>, <var>n</var>)</em></dt>
<dt><a name="index-textread-3"></a>: <em>[<var>a</var>, &hellip;] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>, <var>prop1</var>, <var>value1</var>, &hellip;)</em></dt>
<dt><a name="index-textread-4"></a>: <em>[<var>a</var>, &hellip;] =</em> <strong>textread</strong> <em>(<var>filename</var>, <var>format</var>, <var>n</var>, <var>prop1</var>, <var>value1</var>, &hellip;)</em></dt>
<dd><p>Read data from a text file.
</p>
<p>The file <var>filename</var> is read and parsed according to <var>format</var>.  The
function behaves like <code>strread</code> except it works by parsing a file
instead of a string.  See the documentation of <code>strread</code> for details.
</p>
<p>In addition to the options supported by <code>strread</code>, this function
supports two more:
</p>
<ul>
<li> <code>&quot;headerlines&quot;</code>:
The first <var>value</var> number of lines of <var>filename</var> are skipped.

</li><li> <code>&quot;endofline&quot;</code>:
Specify a single character or
<code>&quot;\r\n&quot;</code>.  If no value is given, it
will be inferred from the file.  If set to <code>&quot;&quot;</code> (empty string) EOLs
are ignored as delimiters.
</li></ul>

<p>The optional input <var>n</var> (format repeat count) specifies the number of
times the format string is to be used or the number of lines to be read,
whichever happens first while reading.  The former is equivalent to
requesting that the data output vectors should be of length <var>N</var>.
Note that when reading files with format strings referring to multiple
lines, <var>n</var> should rather be the number of lines to be read than the
number of format string uses.
</p>
<p>If the format string is empty (not just omitted) and the file contains only
numeric data (excluding headerlines), textread will return a rectangular
matrix with the number of columns matching the number of numeric fields on
the first data line of the file.  Empty fields are returned as zero values.
</p>
<p>Examples:
</p>
<div class="example">
<pre class="example">  Assume a data file like:
  1 a 2 b
  3 c 4 d
  5 e
</pre></div>

<div class="example">
<pre class="example">  [a, b] = textread (f, &quot;%f %s&quot;)
  returns two columns of data, one with doubles, the other a
  cellstr array:
  a = [1; 2; 3; 4; 5]
  b = {&quot;a&quot;; &quot;b&quot;; &quot;c&quot;; &quot;d&quot;; &quot;e&quot;}
</pre></div>

<div class="example">
<pre class="example">  [a, b] = textread (f, &quot;%f %s&quot;, 3)
  (read data into two culumns, try to use the format string
  three times)
  returns
  a = [1; 2; 3]
  b = {&quot;a&quot;; &quot;b&quot;; &quot;c&quot;}

</pre></div>

<div class="example">
<pre class="example">  With a data file like:
  1
  a
  2
  b

  [a, b] = textread (f, &quot;%f %s&quot;, 2)
  returns a = 1 and b = {&quot;a&quot;}; i.e., the format string is used
  only once because the format string refers to 2 lines of the
  data file.  To obtain 2x1 data output columns, specify N = 4
  (number of data lines containing all requested data) rather
  than 2.
</pre></div>


<p><strong>See also:</strong> <a href="Manipulating-Strings.html#XREFstrread">strread</a>, <a href="Simple-File-I_002fO.html#XREFload">load</a>, <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>, <a href="Formatted-Input.html#XREFfscanf">fscanf</a>, <a href="Simple-File-I_002fO.html#XREFtextscan">textscan</a>.
</p></dd></dl>


<a name="XREFtextscan"></a><dl>
<dt><a name="index-textscan"></a>: <em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>)</em></dt>
<dt><a name="index-textscan-1"></a>: <em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>, <var>repeat</var>)</em></dt>
<dt><a name="index-textscan-2"></a>: <em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>, <var>param</var>, <var>value</var>, &hellip;)</em></dt>
<dt><a name="index-textscan-3"></a>: <em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>fid</var>, <var>format</var>, <var>repeat</var>, <var>param</var>, <var>value</var>, &hellip;)</em></dt>
<dt><a name="index-textscan-4"></a>: <em><var>C</var> =</em> <strong>textscan</strong> <em>(<var>str</var>, &hellip;)</em></dt>
<dt><a name="index-textscan-5"></a>: <em>[<var>C</var>, <var>position</var>, <var>errmsg</var>] =</em> <strong>textscan</strong> <em>(&hellip;)</em></dt>
<dd><p>Read data from a text file or string.
</p>
<p>The string <var>str</var> or file associated with <var>fid</var> is read from and
parsed according to <var>format</var>.  The function is an extension of
<code>strread</code> and <code>textread</code>.  Differences include: the ability to
read from either a file or a string, additional options, and additional
format specifiers.
</p>
<p>The input is interpreted as a sequence of words, delimiters (such as
whitespace), and literals.  The characters that form delimiters and
whitespace are determined by the options.  The format consists of format
specifiers interspersed between literals.  In the format, whitespace forms
a delimiter between consecutive literals, but is otherwise ignored.
</p>
<p>The output <var>C</var> is a cell array where the number of columns is determined
by the number of format specifiers.
</p>
<p>The first word of the input is matched to the first specifier of the format
and placed in the first column of the output; the second is matched to the
second specifier and placed in the second column and so forth.  If there
are more words than specifiers then the process is repeated until all words
have been processed or the limit imposed by <var>repeat</var> has been met (see
below).
</p>
<p>The string <var>format</var> describes how the words in <var>str</var> should be
parsed.  As in <var>fscanf</var>, any (non-whitespace) text in the format that is
not one of these specifiers is considered a literal.  If there is a literal
between two format specifiers then that same literal must appear in the
input stream between the matching words.
</p>
<p>The following specifiers are valid:
</p>
<dl compact="compact">
<dt><code>%f</code></dt>
<dt><code>%f64</code></dt>
<dt><code>%n</code></dt>
<dd><p>The word is parsed as a number and converted to double.
</p>
</dd>
<dt><code>%f32</code></dt>
<dd><p>The word is parsed as a number and converted to single (float).
</p>
</dd>
<dt><code>%d</code></dt>
<dt><code>%d8</code></dt>
<dt><code>%d16</code></dt>
<dt><code>%d32</code></dt>
<dt><code>%d64</code></dt>
<dd><p>The word is parsed as a number and converted to int8, int16, int32, or
int64.  If no size is specified then int32 is used.
</p>
</dd>
<dt><code>%u</code></dt>
<dt><code>%u8</code></dt>
<dt><code>%u16</code></dt>
<dt><code>%u32</code></dt>
<dt><code>%u64</code></dt>
<dd><p>The word is parsed as a number and converted to uint8, uint16, uint32, or
uint64.  If no size is specified then uint32 is used.
</p>
</dd>
<dt><code>%s</code></dt>
<dd><p>The word is parsed as a string ending at the last character before
whitespace, an end-of-line, or a delimiter specified in the options.
</p>
</dd>
<dt><code>%q</code></dt>
<dd><p>The word is parsed as a &quot;quoted string&quot;.
If the first character of the string is a double quote (&quot;) then the string
includes everything until a matching double quote&mdash;including whitespace,
delimiters, and end-of-line characters.  If a pair of consecutive double
quotes appears in the input, it is replaced in the output by a single
double quote.  For examples, the input &quot;He said &quot;&quot;Hello&quot;&quot;&quot; would
return the value &rsquo;He said &quot;Hello&quot;&rsquo;.
</p>
</dd>
<dt><code>%c</code></dt>
<dd><p>The next character of the input is read.
This includes delimiters, whitespace, and end-of-line characters.
</p>
</dd>
<dt><code>%[&hellip;]</code></dt>
<dt><code>%[^&hellip;]</code></dt>
<dd><p>In the first form, the word consists of the longest run consisting of only
characters between the brackets.  Ranges of characters can be specified by
a hyphen; for example, %[0-9a-zA-Z] matches all alphanumeric characters (if
the underlying character set is ASCII).  Since <small>MATLAB</small> treats hyphens
literally, this expansion only applies to alphanumeric characters.  To
include &rsquo;-&rsquo; in the set, it should appear first or last in the brackets; to
include &rsquo;]&rsquo;, it should be the first character.  If the first character is
&rsquo;^&rsquo; then the word consists of characters <strong>not</strong> listed.
</p>
</dd>
<dt><code>%N&hellip;</code></dt>
<dd><p>For %s, %c %d, %f, %n, %u, an optional width can be specified as %Ns, etc.
where N is an integer &gt; 1.  For %c, this causes exactly N characters to be
read instead of a single character.  For the other specifiers, it is an
upper bound on the number of characters read; normal delimiters can cause
fewer characters to be read.  For complex numbers, this limit applies to
the real and imaginary components individually.  For %f and %n, format
specifiers like %N.Mf are allowed, where M is an upper bound on number of
characters after the decimal point to be considered; subsequent digits are
skipped.  For example, the specifier %8.2f would read 12.345e6 as 1.234e7.
</p>
</dd>
<dt><code>%*&hellip;</code></dt>
<dd><p>The word specified by the remainder of the conversion specifier is skipped.
</p>
</dd>
<dt><code>literals</code></dt>
<dd><p>In addition the format may contain literal character strings; these will be
skipped during reading.  If the input string does not match this literal,
the processing terminates.
</p></dd>
</dl>

<p>Parsed words corresponding to the first specifier are returned in the first
output argument and likewise for the rest of the specifiers.
</p>
<p>By default, if there is only one input argument, <var>format</var> is <tt>&quot;%f&quot;</tt>.
This means that numbers are read from the input into a single column vector.
If <var>format</var> is explicitly empty (<code>&quot;&quot;</code>) then textscan will
return data in a number of columns matching the number of fields on the
first data line of the input.  Either of these is suitable only when the
input is exclusively numeric.
</p>
<p>For example, the string
</p>
<div class="smallexample">
<pre class="smallexample"><var>str</var> = &quot;\
Bunny Bugs   5.5\n\
Duck Daffy  -7.5e-5\n\
Penguin Tux   6&quot;
</pre></div>

<p>can be read using
</p>
<div class="example">
<pre class="example"><var>a</var> = textscan (<var>str</var>, &quot;%s %s %f&quot;);
</pre></div>

<p>The optional numeric argument <var>repeat</var> can be used for limiting the
number of items read:
</p>
<dl compact="compact">
<dt>-1</dt>
<dd><p>Read all of the string or file until the end (default).
</p>
</dd>
<dt>N</dt>
<dd><p>Read until the first of two conditions occurs: 1) the format has been
processed N times, or 2) N lines of the input have been processed.  Zero
(0) is an acceptable value for <var>repeat</var>.  Currently, end-of-line
characters inside %q, %c, and %[&hellip;]$ conversions do not contribute to
the line count.  This is incompatible with <small>MATLAB</small> and may change in
future.
</p></dd>
</dl>

<p>The behavior of <code>textscan</code> can be changed via property/value pairs.
The following properties are recognized:
</p>
<dl compact="compact">
<dt><code>&quot;BufSize&quot;</code></dt>
<dd><p>This specifies the number of bytes to use for the internal buffer.
A modest speed improvement may be obtained by setting this to a large value
when reading a large file, especially if the input contains long strings.
The default is 4096, or a value dependent on <var>n</var> if that is specified.
</p>
</dd>
<dt><code>&quot;CollectOutput&quot;</code></dt>
<dd><p>A value of 1 or true instructs <code>textscan</code> to concatenate consecutive
columns of the same class in the output cell array.  A value of 0 or false
(default) leaves output in distinct columns.
</p>
</dd>
<dt><code>&quot;CommentStyle&quot;</code></dt>
<dd><p>Specify parts of the input which are considered comments and will be
skipped.  <var>value</var> is the comment style and can be either (1) A string
or 1x1 cell string, to skip everything to the right of it; (2) A cell array
of two strings, to skip everything between the first and second strings.
Comments are only parsed where whitespace is accepted and do not act as
delimiters.
</p>
</dd>
<dt><code>&quot;Delimiter&quot;</code></dt>
<dd><p>If <var>value</var> is a string, any character in <var>value</var> will be used to
split the input into words.  If <var>value</var> is a cell array of strings,
any string in the array will be used to split the input into words.
(default value = any whitespace.)
</p>
</dd>
<dt><code>&quot;EmptyValue&quot;</code></dt>
<dd><p>Value to return for empty numeric values in non-whitespace delimited data.
The default is NaN.  When the data type does not support NaN (int32 for
example), then the default is zero.
</p>
</dd>
<dt><code>&quot;EndOfLine&quot;</code></dt>
<dd><p><var>value</var> can be either an emtpy or one character specifying the
end-of-line character, or the pair
<code>&quot;\r\n&quot;</code> (CRLF).
In the latter case, any of
<code>&quot;\r&quot;</code>, <code>&quot;\n&quot;</code> or
<code>&quot;\r\n&quot;</code> is counted as a (single)
newline.  If no value is given,
<code>&quot;\r\n&quot;</code> is used.
</p>

</dd>
<dt><code>&quot;HeaderLines&quot;</code></dt>
<dd><p>The first <var>value</var> number of lines of <var>fid</var> are skipped.  Note that
this does not refer to the first non-comment lines, but the first lines of
any type.
</p>
</dd>
<dt><code>&quot;MultipleDelimsAsOne&quot;</code></dt>
<dd><p>If <var>value</var> is nonzero, treat a series of consecutive delimiters,
without whitespace in between, as a single delimiter.  Consecutive
delimiter series need not be vertically aligned.  Without this option, a
single delimiter before the end of the line does not cause the line to be
considered to end with an empty value, but a single delimiter at the start
of a line causes the line to be considered to start with an empty value.
</p>
</dd>
<dt><code>&quot;TreatAsEmpty&quot;</code></dt>
<dd><p>Treat single occurrences (surrounded by delimiters or whitespace) of the
string(s) in <var>value</var> as missing values.
</p>
</dd>
<dt><code>&quot;ReturnOnError&quot;</code></dt>
<dd><p>If set to numerical 1 or true, return normally as soon as an error is
encountered, such as trying to read a string using <code>%f</code>.
If set to 0 or false, return an error and no data.
</p>
</dd>
<dt><code>&quot;Whitespace&quot;</code></dt>
<dd><p>Any character in <var>value</var> will be interpreted as whitespace and trimmed;
The default value for whitespace is
<code>&quot;
\b\r\n\t&quot;</code>
(note the space).  Unless whitespace is set to <code>&quot;&quot;</code> (empty) AND at
least one <code>&quot;%s&quot;</code> format conversion specifier is supplied, a space is
always part of whitespace.
</p>
</dd>
</dl>

<p>When the number of words in <var>str</var> or <var>fid</var> doesn&rsquo;t match an exact
multiple of the number of format conversion specifiers, <code>textscan</code>&rsquo;s
behavior depends on whether the last character of the string or file is an
end-of-line as specified by the <code>EndOfLine</code> option:
</p>
<dl compact="compact">
<dt>last character = end-of-line</dt>
<dd><p>Data columns are padded with empty fields, NaN or 0 (for integer fields) so
that all columns have equal length
</p>
</dd>
<dt>last character is not end-of-line</dt>
<dd><p>Data columns are not padded; <code>textscan</code> returns columns of unequal
length
</p></dd>
</dl>

<p>The second output <var>position</var> provides the location, in characters
from the beginning of the file or string, where processing stopped.
</p>

<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>, <a href="Formatted-Input.html#XREFfscanf">fscanf</a>, <a href="Simple-File-I_002fO.html#XREFload">load</a>, <a href="Manipulating-Strings.html#XREFstrread">strread</a>, <a href="Simple-File-I_002fO.html#XREFtextread">textread</a>.
</p></dd></dl>


<p>The <code>importdata</code> function has the ability to work with a wide
variety of data.
</p>
<a name="XREFimportdata"></a><dl>
<dt><a name="index-importdata"></a>: <em><var>A</var> =</em> <strong>importdata</strong> <em>(<var>fname</var>)</em></dt>
<dt><a name="index-importdata-1"></a>: <em><var>A</var> =</em> <strong>importdata</strong> <em>(<var>fname</var>, <var>delimiter</var>)</em></dt>
<dt><a name="index-importdata-2"></a>: <em><var>A</var> =</em> <strong>importdata</strong> <em>(<var>fname</var>, <var>delimiter</var>, <var>header_rows</var>)</em></dt>
<dt><a name="index-importdata-3"></a>: <em>[<var>A</var>, <var>delimiter</var>] =</em> <strong>importdata</strong> <em>(&hellip;)</em></dt>
<dt><a name="index-importdata-4"></a>: <em>[<var>A</var>, <var>delimiter</var>, <var>header_rows</var>] =</em> <strong>importdata</strong> <em>(&hellip;)</em></dt>
<dd><p>Import data from the file <var>fname</var>.
</p>
<p>Input parameters:
</p>
<ul>
<li> <var>fname</var>
The name of the file containing data.

</li><li> <var>delimiter</var>
The character separating columns of data.  Use <code>\t</code> for tab.
(Only valid for ASCII files)

</li><li> <var>header_rows</var>
The number of header rows before the data begins.  (Only valid for ASCII
files)
</li></ul>

<p>Different file types are supported:
</p>
<ul>
<li> ASCII table

<p>Import ASCII table using the specified number of header rows and the
specified delimiter.
</p>
</li><li> Image file

</li><li> <small>MATLAB</small> file

</li><li> Spreadsheet files (depending on external software)

</li><li> WAV file

</li></ul>


<p><strong>See also:</strong> <a href="Simple-File-I_002fO.html#XREFtextscan">textscan</a>, <a href="Simple-File-I_002fO.html#XREFdlmread">dlmread</a>, <a href="Simple-File-I_002fO.html#XREFcsvread">csvread</a>, <a href="Simple-File-I_002fO.html#XREFload">load</a>.
</p></dd></dl>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="Saving-Data-on-Unexpected-Exits.html#Saving-Data-on-Unexpected-Exits" accesskey="1">Saving Data on Unexpected Exits</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<div class="header">
<p>
Previous: <a href="Terminal-Input.html#Terminal-Input" accesskey="p" rel="prev">Terminal Input</a>, Up: <a href="Basic-Input-and-Output.html#Basic-Input-and-Output" accesskey="u" rel="up">Basic Input and Output</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Concept-Index.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
